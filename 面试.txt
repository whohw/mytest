单点登陆的原理
如何防止cookie被盗用
Cookie和Session的区别
Session共享及其好处
mysql主从数据同步的方式
spring 控制器的加载过程
Spring 实例是单例还是多例？会不会有线程问题
如何进行跨机房数据同步？如何保证数据访问的一致性
数据库索引有什么好处？
Mysql如何查看执行计划？
Mysql执行计划的的顺序
如何查看Mysql中SQL执行的快慢？
SQL执行过程net和wait for table的区别?
IO与NIO的区别？NIO中select的原理？NIO缓冲区的默认大小？
使用什么数据库连接池？连接池的工作 原理？常用连接池C3PO,proxool与JNDI的区别？
缓存redis如何应对系统崩溃后的快照问题?
Redis的默认键大小是多少？
线程中sleep与wait的区别？
Restful与dubbo的对比？
二、2015年11月25日下午复试的题目

1.IO和NIO的区别和原理？

（1）    IO是面向流的，NIO是面向缓冲区的

Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

（2）    阻塞与非阻塞IO

Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

（3）    使用单线程Selector来管理多个通道，减少系统开销

2. NIO中select的实现机制

(1)  创建Selector

(2)  向Selector注册通道

(3)  SelectionKey

(4)  通过Selector选择通道

(5)  wakeup

(6)  close()

3.多线程中syschronize、volitile、lock的区别和应用

1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了锁投票，定时锁等候和中断锁等候
     线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，
     如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断
     如果使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情
 
    ReentrantLock获取锁定与三种方式：
    a)  lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁
    b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；
    c)tryLock(long timeout,TimeUnit unit)，   如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；
    d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断
 
2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中
 
3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；

4.乐观锁和悲观锁的区别？

5.数据库中事务的级别

1.    读未提交

2.    读已提交

3.    可重复读

4.    读序列化

6. 数据库行级锁的应用，修改一条记录时是否会加上行级锁

行级锁的优点有：
 在很多线程请求不同记录时减少冲突锁。
 事务回滚时减少改变数据。
 使长时间对单独的一行记录加锁成为可能。

行级锁的缺点有：
 比页级锁和表级锁消耗更多的内存。
 锁是计算机协调多个进程或线程并发访问某一资源的机制，不同的数据库的锁机制大同小异。由于数据库资源是一种供许多用户共享的资源，所以如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。了解锁机制不仅可以使我们更有效的开发利用数据库资源，也使我们能够更好地维护数据库，从而提高数据库的性能。

上述三种锁的特性可大致归纳如下：
1） 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2） 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3） 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

     三种锁各有各的特点，若仅从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如WEB应用；行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。

/* ==================== MySQL InnoDB 锁表与锁行 ======================== */

由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。

7.Spring事务的实现方式和实现原理

8.Spring AOP的实现

9.HTTP长连接和短连接的区别

TCP/IP

TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。

在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。

在传输层中有TCP协议与UDP协议。

在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议

                 UDP包括DNS、TFTP等协议

短连接

连接->传输数据->关闭连接

HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。

 

长连接

连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

 

http的长连接

HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。

 

什么时候用长连接，短连接？

 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

 

而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

 

总之，长连接和短连接的选择要视情况而定。

10.Spring事务的种类和各自的区别

11.Redis的集群方式，主点挂掉后如何将备点切换成主点

12.Mysql的集群方式，主备的数据同步方式，主库挂掉后如何切换从库为主库，有没做过两主两备的集群？

13.如何分析一条慢查询的SQL，MYSQL执行计划的类别（all Table,using index,using where）

14.线程挂掉后，如何在虚拟机上分析。

15.CAP一致性、可用性、分区容忍性，系统中是牺牲了哪一种。

16.Freemarker的缓存机制

17. Zookeeper的实现原理